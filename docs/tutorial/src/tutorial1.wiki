=Writing a client/server Eliom application=

<<div class="wip"|**Work in progress**>>

This chapter and the two following ones are an overview of the features
the Ocsigen framework brings to build Web applications.
They will allow you to understand the philosophy of Eliom
(the Web programming framework in OCaml), and are also a good
starting point to understand other libraries of the Ocsigen project: Lwt, Macaque, etc.

Theses  chapters do  not  aim at  exhaustiveness  but many  references
towards other  chapters are made all  along the text, so  that you can
learn the concepts in detail if you want to.

We assume the reader has a good knowledge of the Objective Caml language.

The present chapter is a tutorial for writing a small client/server
collaborative drawing application. You will learn how to:
* Create new //services//
* Output //valid HTML//
* Send //OCaml code// to be executed //on the client//
* Call //Javascript methods// from OCaml
* Catch //mouse events//
* //Communicate// with the server, in both directions
* Use the //O'Closure// widget library
* Create services with //non-HTML output//

The next chapter is devoted to server side programming.
We will create a new Web site with several pages and user connection. In this chapter, you will learn how to:
* Create a //link// towards another service
* Create //forms//
* Register //session data// or //session services//
* Create services performing //actions// (with no output)
* Dynamically register new services (//continuation based// Web programming)


The third chapter is an overview of miscellaneous features.
We will mix the application from the first chapter
with the one from the second chapter to produce a multi-user
collaborative drawing application.
In this chapter, you will learn how to:
* Integrate a typical Web interaction (links, forms,~ …) with a client side program.
* Use //Macaque// for safe database interaction
* Add //sounds or videos// to your application
* Change pages //without stopping the client side program//
* Connect with external accounts (//openID//) <<span class="wip"|???>>
* Add an Atom stream



If you are not interested in client-side programming you can safely skip
most of the first chapter (although I recommend you read at least the first section, which explains
the basics). Conversely, if you are not interested in standard Web interactions,
with sessions links, and forms, you can skip the second chapter.

Keep in mind that one of the key feature of Eliom is that it allows one to mix
commonplace Web interactions (URLs, forms, links, bookmarks, back button)
with dynamic client side features. In particular, the client-side
program **does not stop** when the user clicks a link, sends a form, or
presses the back button--yet the user still can save bookmarks on pages!
This opens up a wide field of new possibilities,
and should facilitate the emergence of new kinds of Web applications.\\


In this chapter, we will write a 
[[site:graffiti/|collaborative drawing application]].
\\
<<|object class="graffiti" type="text/html" data="http://ocsigen.org/graffiti/" >>

==@@id="basics"@@ Basics ==

In this first section, we will build a collaborative drawing application. It is a client/server Web application displaying an area where users can draw using the mouse, and see what other users are drawing.

===My first page===
<<div class="concepts"|Services\\Configuration file\\Static validation of HTML>>
Our Web application consists of a single page for now.
Let's start by creating a very basic page.
We define the service that will implement this page by the following declaration: 
<<code language="ocaml"|open Lwt
open XHTML5.M
open Eliom_services
open Eliom_parameters
open Eliom_output.Xhtml5

let main_service =
  register_service ~path:["graff"] ~get_params:unit
    (fun () () -> return (html (head (title (pcdata "")) [])
                               (body [h1 [pcdata "Graffiti"]])))>>

The same, written with fully qualified names (without {{{open}}}):
<<code language="ocaml"|let main_service =
  Eliom_output.Xhtml5.register_service ~path:["graff"] ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (XHTML5.M.html (XHTML5.M.head (XHTML5.M.title (XHTML5.M.pcdata "")) [])
                       (XHTML5.M.body [XHTML5.M.h1 [XHTML5.M.pcdata "Graffiti"]])))
>>

Copy one of the two pieces of code above in a file {{{graffiti.ml}}}, 
(or download it form [[manual/dev/files/v1/graffiti.ml|here]])
then compile it by typing:

{{{ocamlfind ocamlc -thread -package ocsigen -c graffiti.ml}}}

This will create a file called {{{graffiti.cmo}}}.

Take the configuration file provided [[manual/dev/files/v1/graffiti1.conf|here]],
then launch Ocsigen server, with the following command:
{{{
ocsigen -c graffiti1.conf
}}}
Your page is now available at URL
<<span class="code"|~http:~/~/localhost:8080/graff>>.


<<div class="encadre"|====Services====
Unlike typical Web programming techniques (CGI, PHP,~ ...),
with Eliom, you don't write one file for each URL, but
a single Caml module (*.cmo or *.cma) for the whole Web site.

The <<ocsigendoc version="dev" file="Eliom_services.html"|<<span class="code"|Eliom_services>>>> module allows to create new entry points to
your Web site, called //services//. In general, services are
attached to a URL and generate a Web page.
Services are represented by OCaml values, through which
you must register a function that will generate a page.

The {{{~path}}} parameter corresponds to the URL where you want to attach
your service. It is a list of strings.
The value <<span class="code"|["foo"; "bar"]>> corresponds to the URL
  <<span class="code"|foo/bar>>.      \\
  <<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
  (that is: the default page of the directory <<span class="code"|dir>>).       
>>
<<div class="encadre"|====Configuration file====
Consider the sample configuration file below.
It contains various directives for Ocsigen server (port, log files,
extensions to be loaded, etc.), and something like:

<<div class="pre"|<host>
    <static dir="~///path_to///graffiti" />
    <eliom module="~///path_to///graffiti.cmo" />
</host>

>>

These instructions tell the server that pages to be served are:
* static files from the directory <<span class="code"|~///path_to///graffiti>>
if they exist, and
* pages generated by the Eliom application {{{graffiti.cmo}}} otherwise.

>>

<<div class="encadre"|====Static validation of HTML====
There are several ways to create pages for Eliom. 
You can generate pages as strings (as in other Web frameworks).
But we prefer checking that the HTML will be correct at compile time.
Eliom provides several modules to do that, either using OcamlDuce (if you
have it installed) or using OCaml's polymorphic variants.
This tutorial is using the second solution, using the module
<<ocsigendoc version="dev" file="Eliom_output.Xhtml5.html"|<<span class="code"|Eliom_output.Xhtml5>>>>. This module defines a construction function
for each HTML5 tag.

//Note that it is also possible to use the usual HTML syntax.
See [[wiki(15):xhtmlsyntax|here]] for more information.//

Typing of HTML with <<ocsigendoc version="dev" file="XHTML5.M.html"|<<span class="code"|XHTML5.M>>>> and <<ocsigendoc version="dev" file="Eliom_output.Xhtml.html"|<<span class="code"|Eliom_output.Xhtml>>>>
is very strict and compels you to respect HTML5 standard
(with some limitations). For example if you write:
  
<<code language="ocaml"|(html
   (head (title (pcdata "")) [pcdata ""])
   (body [pcdata "Hallo"]))
>>
  
You will get the following error message:
{{{
Error: This expression has type ([> `PCDATA ] as 'a) XHTML5.M.elt
       but an expression was expected of type Xhtml5types.head_content_fun XHTML5.M.elt
       Type 'a is not compatible with type Xhtml5types.head_content_fun =
           [ `Base
           | `Command
           | `Link
           | `Meta
           | `Noscript of [ `Link | `Meta | `Style ]
           | `Script
           | `Style ] 
       The second variant type does not allow tag(s) `PCDATA
}}}

  
<<span class="code"|Xhtml5types.head_content_fun>>
is the type of content allowed inside
<<span class="code"|<head>>>.
You see that {{{`PCDATA}}} (i.e. raw text) is not in this polymorphic
variant type.

**Another example:** In XHTML5, some tags cannot be empty. For example
<<span class="code"|<table>>> must contain at least one row.
To enforce this, the <<ocsigendoc version="dev" file="XHTML5.M.html" fragment="VALtable"|<<span class="code"|XHTML5.M.table>>>> function takes two parameters:
the first one is the first row, the second one is a list
containing all the other rows.
(same thing for <<span class="code"|<tr>>> <<span class="code"|<form>>>
<<span class="code"|<dl>>> <<span class="code"|<ol>>> <<span class="code"|<ul>>>
<<span class="code"|<dd>>> <<span class="code"|<select>>> ...)
This forces the user to handle the empty list case specially and thus make
the output conform to the recommendation from the W3C.

//Strict typing of HTML may seem arduous initially,
but in fact it is very easy to get used to.
It actually saves a huge amount of
debugging time as you will never have to bother about the validity of
pages afterwards.//

A more detailed introduction to <<span class="code"|XHTML5.M>> is available
[[wiki(15):xhtmlsyntax|here]] and
<<ocsigendoc version="dev" file="XHTML5.M.html"|here>>.

>>

<<div class="encadre"|====Lwt====
    **Important warning:** All the functions you write must be written
    in collaborative manner using Lwt. Lwt is a very convenient way to
    implement concurrent programs in OCaml, which is now widely used
    even for applications not related to Ocsigen.

    For now we will just use the {{{Lwt.return}}} function as above.
    We will come back later on Lwt programming.
    You can also have a look at the [[wiki(21):|Lwt programming guide.]]
>>

===Execute parts of the program on the client===
<<div class="concepts"|Service sending an application <<span class="new"|New in 1.90!>>\\
Client and server code <<span class="new"|New in 1.90!>>\\
Compiling a Web application with server and client parts <<span class="new"|New in 1.90!>>\\
Calling Javascript methods with Js_of_ocaml <<span class="new"|New in 1.90!>>>>
To create our first service, we used the function
{{{Eliom_output.Xhtml5.register_service}}}, as we wanted to return HTML5.

But actually we want our service to send an Eliom application.
To do that, we will create our own registration module by using the
functor {{{Eliom_output.Eliom_appl}}}:

<<code language="ocaml"|open XHTML5.M

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params = Eliom_output.default_appl_params
    end)
>>

It is now possible to use this module for registering our main service:
<<code language="ocaml"|let main_service =
  My_appl.register_service ~path:[""] ~get_params:Eliom_parameters.unit
    (fun () () -> Lwt.return [h1 [pcdata "Graffiti"]])
>>

Download the current version [[manual/dev/files/v2/graffiti.ml|here]]
and the [[manual/dev/files/v2/graffiti1.conf|configuration file]].
<<div class="encadre"|==== About the {{{Eliom_output.Eliom_appl}}} functor ====
The {{{Eliom_output.Eliom_appl}}} we used here takes as parameters
the information about the application:
* The application name
* The parameters of the application (here we use the defaults)

Note that the function implementing the service now returns only the
body of the page, and not the full page. The header is created
automatically from the information you gave to the functor
(this is customizable).

HTML is created using the {{{XHTML5.M}}} module, as before.
>>

We now want to add some OCaml code to be executed by the browser.
We start by a very basic program, that will display a message to the user
by calling the Javascript function {{{alert}}}. We add the following lines
to the program:

<<code language="ocaml"|{client{
  let _ = Dom_html.window##alert(Js.string "Hello")
}}
>>

As you can see, we are using a syntax extension to distinguish
between server and client code in the same file.
Put the [[/manual/dev/files/v3/Makefile|default Makefile]]
and the [[/manual/dev/files/v3/graffiti2.conf|new configuration file]]
in your directory. You may want to adapt the configuration file to set
the paths, especially the directory for static files. (To make things easier
for the tutorial, you can use your source directory but keep in mind
that it is not necessary (and sometimes dangerous) to put {{{.ml}}}
and {{{.cma}}}/{{{.cmo}}} in the static files directory!)


The default {{{Makefile}}} recognizes files using Eliom's syntax extension by
their extension {{{.eliom}}} (instead of {{{.ml}}}).
Put the new version of our program in a file {{{graffiti.eliom}}}
or download it from [[manual/dev/files/v3/graffiti.eliom|here]]
and compile it by typing:
{{{
make
}}}
This will generate a file called {{{graffiti.cma}}}
and another one called {{{graffiti.js}}}. The latter //must be placed in the
static file directory//.

Now run Ocsigen server:
{{{
ocsigen -c graffiti2.conf
}}}
Your page is now available at URL
<<span class="code"|~http:~/~/localhost:8080/>>.
It should open an alert box. If not, check that the static file directory 
in the configuration file is correct.

<<div class="encadre"|==== Client side code ====
Eliom's syntax extension implements four kinds of quotations:
* {{{ {client{ ... }} }}} for client side code
* {{{ {server{ ... }} }}} (optional) for server side code
* {{{ {shared{ ... }} }}} for code that will be used both for the server and the client
* {{{ {{ ... }} }}} for client side code in expressions (see later)

In the default Makefile we automatically split the code, compile the server
part as usual, and compile the client part using {{{js_of_ocaml}}},
to create a Javascript file.
>>

<<div class="encadre"|==== Js_of_ocaml ====
The client-side parts of the program are compiled to Javascript by
Js_of_ocaml, which recompiles OCaml bytecode, generating Javascript.
It is easy to bind Javascript libraries to call Javascript functions
from OCaml programs. In the example, we are using the {{{Dom_html}}}
module, which is a binding to allow the manipulation of an HTML page. <<span class="wip"|See the interface of the {{{Dom_html}}} module **here**.>>

Js_of_ocaml is using a syntax extension to call Javascript methods:
* {{{obj##m(a, b, c)}}} to call the method {{{m}}} of object {{{obj}}}
with parameters {{{(a, b, c)}}}
* {{{obj##m}}} to get a property
* {{{obj##m <- e}}} to set a property
* {{{jsnew constr (e1, ..., en)}}} to call a Javascript constructor

Find more information about Js_of_ocaml in
[[wiki(30):/lib/overview|Js_of_ocaml's manual]].
>>

==@@id="graffiti"@@ Collaborative drawing application ==

===Drawing on a canvas===
<<div class="concepts"|Canvas>>
To draw something on the page, we will use an HTML5 canvas.
We define a client-side function called {{{draw}}} to draw a line.
Then when the service is called, we want to add dynamically a canvas
to the page, and draw a line.

Here is the (full) new version of the program:
<<code language="ocaml"|{shared{
  open XHTML5.M
  let width = 700
  let height = 400
}}

module My_appl =
  Eliom_output.Eliom_appl (
    struct
      let application_name = "graffiti"
      let params = Eliom_output.default_appl_params
    end)

{client{
  let draw ctx (color, size, (x1, y1), (x2, y2)) =
    ctx##strokeStyle <- (Js.string color);
    ctx##lineWidth <- float size;
    ctx##beginPath();
    ctx##moveTo(float x1, float y1);
    ctx##lineTo(float x2, float y2);
    ctx##stroke()
}}

let main_service =
  My_appl.register_service ~path:[""] ~get_params:Eliom_parameters.unit
    (fun () () ->
       Eliom_services.onload
         {{
           let canvas = Dom_html.createCanvas Dom_html.document in
           let ctx = canvas##getContext (Dom_html._2d_) in
           canvas##width <- width; canvas##height <- height;
           ctx##lineCap <- Js.string "round";

           Dom.appendChild Dom_html.document##body canvas;

           draw ctx ("#ffaa33", 12, (10, 10), (200, 100))
         }};
      Lwt.return [h1 [pcdata "Graffiti"]])
>>

Since we want to draw the canvas only on that page and not on the other (future)
pages of the site, we use the function {{{Eliom_services.onload}}} to
describe the code to be executed when this service in called.


<<div class="encadre"|====  ====
Note that we use the function {{{Js.string}}} from Js_of_ocaml's library
to convert OCaml string into JS strings.
>>

Download the current version of the program
[[manual/dev/files/v4/graffiti.eliom|here]].


===Single user drawing application===
<<div class="concepts"|Mouse events with arrows <<span class="new"|New in 1.90!>>>>
We now want to catch mouse events to draw lines with the mouse.
To do that, we will use the <<span class="wip"|very experimental>>
{{{Event_arrows}}} module from Js_of_ocaml's library.

Add
<<code language="ocaml"|  open Event_arrows
>>
in client side code (for example just before the draw function)
and replace the line
<<code language="ocaml"|           draw ctx ("#ffaa33", 12, (10, 10), (200, 100))
>>
by the following piece of code:
<<code language="ocaml"|          let x = ref 0 and y = ref 0 in
          let set_coord ev =
            let x0, y0 = Dom_html.elementClientPosition canvas in
            x := ev##clientX - x0; y := ev##clientY - y0 in
          let compute_line ev = 
            let oldx = !x and oldy = !y in
            set_coord ev;
            ("#ff9933", 5, (oldx, oldy), (!x, !y))
          in
          let line ev = draw ctx (compute_line ev) in
          ignore (run (mousedowns canvas
                         (arr (fun ev -> set_coord ev; line ev)
                          >~>> first [mousemoves Dom_html.document (arr line);
                                     mouseup Dom_html.document >~>> (arr line)])) ());
>>

Compile, run the program and draw!

Download the current version of the program
[[manual/dev/files/v5/graffiti.eliom|here]].

We use to references {{{x}}} and {{{y}}} to record the last mouse position.
The function {{{set_coord}}} updates these references from mouse event data.
The function {{{compute_line}}} computes the coordinates of a line from
the initial (old) coordinates to the new coordinates--the event data sent as a parameter.

The event handling takes place as follows:\\
For each mousedown event on the canvas, do {{{set_coord}}} then {{{line}}}
(this will draw a dot), then behave as the first of the two following
lines to terminate:
* For each mousemove event on the document, call {{{line}}} (never terminates)
* If there is a mouseup event on the document, call {{{line}}}.

<<div class="encadre"|==== Handling events with arrows ====
The module {{{Event_arrows}}} allows us to define event listeners easily
(using arrows). An arrow from {{{'a}}} to {{{'b}}}
has type {{{('a, 'b) Event_arrows.t}}}. The operator {{{>>>}}} is used
to bind the output of an arrow to the input of the following one.

For example {{{(mouseup Dom_html.document)}}} is an arrow from
{{{unit}}} to {{{Dom_html.mouseEvent Js.t}}}.

The combinator {{{arr}}}
transforms a function of type {{{'a -> 'b}}} into an arrow of type
{{{('a, 'b) Event_arrows.t}}}. There is also a combinator {{{lwt_arr}}} to
transform a function of type {{{'a -> 'b Lwt.t}}} into an arrow of type
{{{('a, 'b) Event_arrows.t}}}.

Combinators like {{{mousedowns}}} or {{{mousemoves}}} (ending by "s")
take as parameters the target of the event and an arrow that will be called
each time the event occures.

The function
{{{
Event_arrows.run :('a, unit) t -> 'a -> canceller
}}}
sets up an event handler. It returns a "canceller" that you can use to cancel
it:
{{{
let c = Event_arrows.run ( ... ) in
...
Event_arrows.cancel c
}}}

The combinator {{{first}}} takes a list of arrows and behaves as the first
to terminate. All the other arrows in the list are cancelled.
>>

<<div class="wip"|**Warning** Event arrows will evolve in the near future.>>

===Collaborative drawing application===
<<div class="concepts"|Client server communication <<span class="new"|New in 1.90!>>>>
We now want to do the following:
* Send the coordinates to the server when the user draw a line, then
* Dispatch the coordinates to all connected users.

<<div class="wip"|To do this we use the experimental {{{Eliom_bus}}}
module, that will evolve in the near future. More explanation when this
module is updated.>>

We first declare a shared type containing the color and coordinates of
drawn lines.
<<code language="ocaml"|{shared{
type messages = (string * int * (int * int) * (int * int)) deriving (Json)
}}
>>
We annotate with {{{deriving (Json)}}} to allow safe deserialization
of this type. This is defined in the Deriving syntax extension. This annotation
can only be added on types containing exclusively basics type or other types
annotated with deriving. For more information, see
<<span class="wip"|Deriving documentation>>

<<code language="ocaml"|let bus = Eliom_bus.create Json.t<messages> >>
The value {{{Json.t<messages>}}} describes the
contents of messages, it is used on server side for deserialization. 

To send the coordinates to the server, we just replace the function {{{line}}}
by:
<<code language="ocaml"|           let (bus:messages Eliom_client_bus.t) = %bus in
           let line ev =
             let v = compute_line ev in
             let _ = Eliom_client_bus.write bus v in
             draw ctx v
           in
>>

<<span class="wip"|As of now {{{bus}}} type needs to be explicitely annotated, this will be corrected soon.>>

<<code language="ocaml"|           let _ = Lwt_stream.iter (draw ctx) (Eliom_client_bus.stream bus) in
>>
And finaly we have to draw the lines received.

Now you can try the program using two browser windows to see that the lines
are drawn on both.

Download the current version of the program
[[manual/dev/files/v6/graffiti.eliom|here]], and the current Makefile
[[manual/dev/files/v6/Makefile|here]].


<<div class="encadre"|==== Antiquotations: Using server side values in client code ====
<<div class="wip"|//soon//>>
>>
<<div class="encadre"|==== Communication channels ====
<<div class="wip"|//soon//>>
>>

<<div class="wip"|**Warning** The syntax of anti-quotations may change in the future>>

===Color and size of the brush===
<<div class="concepts"|Widgets with O'Closure <<span class="new"|New in 1.90!>>>>
In this section, we will add two widgets, taken from the O'Closure widget
library. We need to add some stylesheets and one JS file in the headers of
our page. We do this by modifying the {{{params}}} value given to the
{{{Eliom_output.Eliom_appl}}} functor:
<<code language="ocaml"|      let params =
        {Eliom_output.default_appl_params with
           Eliom_output.ap_title = "graffiti";
           Eliom_output.ap_headers_before =
            [
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/graffiti.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/common.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/hsvpalette.css")
                ();
              XHTML5.M.link ~rel:[ `Stylesheet ]
                ~href:(XHTML5.M.uri_of_string"./css/slider.css")
                ();
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "http://closure-library.googlecode.com/svn/trunk/closure/goog/base.js")
                   ] (XHTML5.M.pcdata "");
              XHTML5.M.script
                ~a:[XHTML5.M.a_src (XHTML5.M.uri_of_string "./graffiti_req.js")
                   ] (XHTML5.M.pcdata "");
            ];
        }
>>

You need to install some stylesheets and images.
Extract <<srcfile src="graffiti-static.tar.gz">> in your static files directory.

The file {{{graffiti_req.js}}} is generated by the Makefile according
to the {{{graffiti.js}}} to load dynamically the Google Closure files
we need.

<<code language="ocaml"|          (* Size of the brush *)
          let slider = jsnew Goog.Ui.slider(Js.null) in
          slider##setMinimum(1.);
          slider##setMaximum(80.);
          slider##setValue(10.);
          slider##setMoveToPointEnabled(Js._true);
          slider##render(Js.some Dom_html.document##body);
          
          (* The color palette: *)
          let pSmall = 
            jsnew Goog.Ui.hsvPalette(Js.null, Js.null,
				     Js.some (Js.string "goog-hsv-palette-sm"))
          in
          pSmall##render(Js.some Dom_html.document##body);
>>
Finally, replace last line of the function {{{compute_line}}} by;
<<code language="ocaml"|            let color = Js.to_string (pSmall##getColor()) in
            let size = int_of_float (Js.to_float (slider##getValue())) in
            (color, size, (oldx, oldy), (!x, !y))
>>

To compile, we need to add {{{oclosure}}} to the list of packages used by the client, in the makefile.
<<code language="Makefile"|CLIENTLIB := -package oclosure>>

Download the current version of the program
[[manual/dev/files/v7/graffiti.eliom|here]], and the current Makefile
[[manual/dev/files/v7/Makefile|here]].


<<div class="encadre"|====O'Closure====
O'Closure is a Js_of_ocaml binding for the Google Closure widget library
(used for example in GMail, Google calendar or Google Maps).
You can use it for building complex user interfaces for your Eliom application.
The full documentation is available [[wiki(33):|here]].
>>

<<div class="wip"|//Fix the directories for static files and Google Closure//>>


===Sending the initial image===
<<div class="concepts"|Services sending other data types>>
To finish, we want to save the current drawing on server side and send the 
current image when a new user arrives. To do that, we will use the
[[http://www.cairographics.org/cairo-ocaml/|Cairo binding]] for OCaml.

The {{{draw_server}}} function below is the equivalent of the {{{draw}}}
function on the server side (in an ideal world, we would have a common interface
for canvas so that we could share the code).
The {{{image_string}}} function outputs the PNG image in a string.
<<code language="ocaml"|
let rgb_from_string color = (* color is in format "#rrggbb" *)
  let get_color i = (float_of_string ("0x"^(String.sub color (1+2*i) 2))) /. 255. in
  try get_color 0, get_color 1, get_color 2 with | _ -> 0.,0.,0.

let draw_server, image_string = 
  let surface = Cairo.image_surface_create Cairo.FORMAT_ARGB32 ~width ~height in
  let ctx = Cairo.create surface in
  ((fun ((color : string), size, (x1, y1), (x2, y2)) ->

    (* Set thickness of brush *)
    Cairo.set_line_width ctx (float size) ;
    Cairo.set_line_join ctx Cairo.LINE_JOIN_ROUND ;
    Cairo.set_line_cap ctx Cairo.LINE_CAP_ROUND ;
    let red, green, blue =  rgb_from_string color in
    Cairo.set_source_rgb ctx ~red ~green ~blue ;

    Cairo.move_to ctx (float x1) (float y1) ;
    Cairo.line_to ctx (float x2) (float y2) ;
    Cairo.close_path ctx ;
    
    (* Apply the ink *)
    Cairo.stroke ctx ;
   ),
   (fun () ->
     let b = Buffer.create 10000 in
     (* Output a PNG in a string *)
     Cairo_png.surface_write_to_stream surface (Buffer.add_string b);
     Buffer.contents b
   ))

let _ = Lwt_stream.iter draw_server (Eliom_bus.stream bus)
>>

Now we define a service that will send the picture:
<<code language="ocaml"|
let imageservice =
  Eliom_output.Text.register_service
    ~path:["image"]
    ~get_params:Eliom_parameters.unit
    (fun () () -> Lwt.return (image_string (), "image/png"))
>>

<<div class="encadre"|====Eliom_output====
The module {{{Eliom_output}}} defines several modules with registration
functions for a variety of data types. We have already seen 
{{{Eliom_output.Xhtml5}}} and {{{Eliom_output.Eliom_appl}}}.
The module {{{Eliom_output.Text}}} sends any text output.
The handler function must return a pair consisting of the string and the content-type.

There are also several other output modules, for example:
* {{{Eliom_output.Files}}} to send static files
* {{{Eliom_output.Redirection}}} to create a redirection towards another page
* {{{Eliom_output.Any}}} to create services that choose themselves what
they want to send
* {{{Eliom_output.Caml}}} to send marshaled OCaml data to be used in a
client side program
* {{{Eliom_output.Action}}} to create service with no output
(the handler function just performs a side effect on the server)
and reload the current page (or not). We will see an example of actions
in the next chapter.

>>

We now want to load the initial image once the canvas is created.
Add the following lines just between the creation of the canvas
and the creation of the slider:
<<code language="ocaml"|           (* The initial image: *)
           let img = Dom_html.createImg Dom_html.document in
           img##alt <- Js.string "canvas";
           img##src <- Js.string (Eliom_output.Xhtml5.make_string_uri ~service:%imageservice ());
           img##onload <- Dom_html.handler (fun ev -> ctx##drawImage(img, 0., 0.); Js._false);
>>

To compile, add {{{cairo}}} to the server packages in the makefile.
<<code language="Makefile"|CLIENTLIB := -package ocsigen.deriving.Json -package cairo>>
The module {{{graffiti.cma}}} depends on {{{cairo}}} to be able to load. To achieve this, we add  
<<div class="pre"|
    <extension findlib-package="cairo"/>
>>
in the configuration file.

<<div class="wip"|//Simplify this (write this with Xhtml5 and higher level interface?) etc.//>>


The first version of the program is now complete.
Download the <<srcfile src="v8/graffiti.eliom"|full code of the program>>, 
the <<srcfile src="v8/Makefile">>,
the <<srcfile src="v8/graffiti2.conf"|configuration file>>,
and the <<srcfile src="graffiti-static.tar.gz"|static files>>.

<<div class="exercices"|
====Exercises====
* Add an O'Closure button to make possible to download the
current image and save it to the hard disk (reuse the service {{{imageservice}}}).
* Add an O'Closure button with a color picker to select a color from the drawing.  (Modify mouse events and use the function {{{Dom_html.pixel_get}}}).
>>
