=Services=

<<wip|
The documentation is now mostly complete, but we are still working on it
(some parts need to be reworked, some small parts are missing).
We will release it as a PDF book in a few week.
Any help appreciated.>>
<<wip|Some links and ref are currently broken.>>

From this chapter to the remainder of the book, we assume you've read the
[[wiki(36):|Ocsigen framework tutorial]] which gives an overview of
the whole project and explains the main concepts. In particular, we suppose
you have basic knowledge on how to define services with parameters,
create links and forms, and use Eliom references.

Each chapter in this part concentrates on a particular Eliom concept, going into full detail.
They can be read in any order, according to your needs.

==General principles==

===Defining services===

With Eliom, pages are generated by //services//.
A service is typically associated with a URL (possibly with optional parameters).
Pages are generated by an associated OCaml function, registered on the service (known as a //service handler//),
that will generate the page.

For example, the following piece of code defines a service without
any parameters, attaches it to the path {{{/coucou}}} of the web site,
and registers on it a function which generates a simple HTML page:

<<code language="ocaml"|let coucou =
  Eliom_output.Html5.register_service
    ~path:["coucou"]
    ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (HTML5.M.html
          (HTML5.M.head (HTML5.M.title (HTML5.M.pcdata "")) [])
          (HTML5.M.body [HTML5.M.h1 [HTML5.M.pcdata "Hallo!"]])))
>>

The handler parameters are GET and POST parameters
(See chapter <<a_manual chapter="params"| parameters>>)

The creation of the service and registration of the handler can be
split into two distinct operations using <<a_api project="eliom"
subproject="server" | val Eliom_services.service >> and <<a_api
project="eliom" subproject="server" | val Eliom_output.Html5.register >>
(see for example in section * * calc).

Services registered with <<span class="code"|register_service>>
are the main entry points for the Web site.
They are available for all users, and are called //main services//.

<<wip| Why is this example here ? I think it should be removed >>

Here is an example of service with side effects, that provides a counter for the number of visits to this service.
<<code language="ocaml"|open HTML5.M
let count =
  let next =
    let c = ref 0 in
      (fun () -> c := !c + 1; !c)
  in
  Eliom_output.Html5.register_service
    ~path:["count"]
    ~get_params:unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "counter")) [])
         (body [p [pcdata (string_of_int (next ()))]])))
>>

(See <<a_manual chapter="state" fragment="perscount" | here >>
<<a_manual chapter="state" fragment="perscount" |here>> for a version of this
counter that persists after relaunching the server).


<<concept title="Paths" |


<<span class="code"|["foo"; "bar"]>> corresponds to the URL
<<span class="code"|foo/bar>>.  \\
<<span class="code"|["dir"; ""]>> corresponds to the URL <<span class="code"|dir/>>
(that is: the default page of the directory <<span class="code"|dir>>).   \\
The empty list <<span class="code"|[]>> is equivalent to <<span class="code"|[""]>>.\\

//Warning://
You cannot create a service on path <<span class="code"|["foo"]>>
(URL <<span class="code"|foo>>, without slash at the end)
and another on path <<span class="code"|["foo";"bar"]>>
(URL <<span class="code"|foo/bar>>) because <<span class="code"|foo>> can not be
both a directory and a file.
Be also careful not to use a path as a directory with
Eliom, if it is a file for Staticmod (and vice versa).

//Warning://
<<span class="code"|["foo";"bar"]>> is not equivalent to
<<span class="code"|["foo/bar"]>>.
In the latter, the "/" will be encoded in the URL.\\

The following example shows how to define the default page for
a directory.
<<code language="ocaml"|open HTML5.M
let default = Eliom_output.Html5.register_service ["rep";""] unit
  (fun () () ->
    Lwt.return
     (html
      (head (title (pcdata "")) [])
      (body [p [pcdata "default page. rep is redirected to rep/"]])))
>>

>><<|concept>>

===Services and Lwt===

Remember that a Web site written with Eliom is an OCaml application.
This application must be able to handle several requests at the same
time, in order to prevent a single request from making the whole server hang.
To make this possible, Ocsigen uses //cooperative threads//
(implemented in monadic style) which make them really easy
to use (see <<a_api project="lwt" | module Lwt >> module).

Below is an example of a page written in a non-cooperative way, that has the effect of stopping the entire
server for 5 seconds. No one will be able to query the server during
this period:

<<code class="donotrun" language="ocaml" |open HTML5.M
let looong =
  Eliom_output.Html5.register_service
    ~path:["looong"]
    ~get_params:unit
    (fun () () ->
       Unix.sleep 5;
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>


To solve this problem, use a cooperative version of
<<a_api project="lwt" | val Lwt_unix.sleep >>:

<<code language="ocaml"|open HTML5.M
let looong =
  Eliom_output.Html5.register_service
    ~path:["looong"]
    ~get_params:unit
    (fun () () ->
       Lwt_unix.sleep 5.0 ~>>= fun () ->
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>

If you want to use, say, a database library that is not written
 in a cooperative way, but is thread-safe for preemptive threads,
 use the <<span class="code"|Lwt_preemptive>> module to
 detach the computation. In the following example,
 we simulate the request by making a call to <<span class="code"|Unix.sleep>>:

<<code language="ocaml"|let looong2 =
  register_service
    ~path:["looong2"]
    ~get_params:unit
    (fun () () ->
       Lwt_preemptive.detach Unix.sleep 5 ~>>= fun () ->
       Lwt.return
         (html
           (head (title (pcdata "")) [])
           (body [h1 [pcdata "Ok now, you can read the page."]])))
>>



===GET and POST methods===

The two most common HTTP methods are GET and POST requests.
* The GET method is intended to be used to retrieve a document
from the server. The page is generated mainly according to the information
contained in the URL.  URLs may contain parameters (consisting of name-value pairs in the URL string), and these parameters
may come from HTML forms.
* The POST method is used to send data to the server (files, for example),
but also values coming from an HTML form. Data is sent in the body of the HTTP
request. It is possible to use the POST method with an empty body.

In HTML, it is not possible to mix GET and POST parameters in forms, but
a form parameter can use a URL with (fixed) GET parameters.
Unlike GET, requests made with POST do not affect the URL string.

<<concept title="POST or GET?" |
POST and GET methods are not equivalent, and you must be very careful
if you want to use one or the other.\\

Remember that only GET services are bookmarkable. The HTTP method and
POST parameters are not stored in bookmarks.\\
Use the GET method if you want the user to be able to come back to the service
later or to write the URL manually.\\
Use the POST method for //hidden service//, that is when you want a
different behaviour
between the first click and a reload of the page. Usually using
POST method triggers an action on server side
(like a payment, or adding something in a database), and you don't want
it to succeed several times if the page is reloaded or bookmarked.
>>

The URL of a POST service must correspond to an existing GET service,
otherwise, no one will answer if you turn back later with the GET method.
To ensure that the corresponding GET service exists, POST services
are created using a function taking a GET service (called a //fallback//)
as parameter, instead of the path. Example:
<<code language="ocaml"|open HTML5.M
let get_service =
  Eliom_output.Html5.register_service
    ~path:["post"]
    ~get_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "")) [])
         (body [h1 [pcdata "Version of the page with GET method"]])))

let post_service =
  Eliom_output.Html5.register_post_service
    ~fallback:get_service
    ~post_params:Eliom_parameters.unit
    (fun () () ->
      Lwt.return
        (html
         (head (title (pcdata "")) [])
         (body [h1 [pcdata "Version of the page using POST method"]])))
>>



===External services===

It is possible to define external services, that is, services that belong
to an external Web site (on the same server of not).
To do that, use the functions {{{Eliom_services.external_service}}}
(for using the GET method),
or {{{Eliom_services.external_post_service}}}
(for using the POST method).

See an example section * * links.

===@@id="staticparts"@@Using Eliom together with Staticmod===

<<wip|ou alors faire une section static content, en disant bien
qu'il ne faut pas le mettre dans le ml (et suggérer db, et fichiers).
De tte façon il faut le dire qqpart.
>>

<<a_manual project="ocsigenserver" chapter="staticmod" | Staticmod>>
is an Ocsigenserver extension serving static (non-generated) files
(for examples images and stylesheets). It can be used together with
Eliom. The predefined service <<a_api| val Eliom_services.static_dir
>> can be used to make links to static files. It takes as parameter
the path of the file.  \\

For example
<<code language="ocaml"|a (static_dir ()) [pcdata "download image"] ["ocsigen10.png"]
>>
creates this link: [[site:ocsigen10.png|download image]]

It is also possible to send static files using Eliom, with
<<a_api| module Eliom_output.Files>>
(<<a_manual chapter="services" fragment="eliomfiles" |see later>>).




==Predefined output modules for services==

All the services we have defined so far in this section are registered using
<<a_api | val Eliom_output.Html5.register_service>> with a handler functions
returning a value of type {{{HTML5_types.html HTML5.M.elt Lwt.t}}}.
If you want to create other types of outputs, you need to use other registration
modules, taken from a large set of predefined modules (output raw text,
redirections, files, portions of pages, etc.). It is also possible to create
your own output modules.

Output modules may define options for the registration function.
For example, the redirection ouput module allows to choose between permanent
and temporary redirection:

<<code language="ocaml"|Eliom_output.Redirection.register_service
  ~options:`Permanent
  ~path:["redirection"]
  ~get_params:Eliom_parameters.unit
>>

===Summary of predefined output modules===

<<wip|Add types and options for each module?>>


Services can send several types of data, using a variety of predefined modules.
It is also possible to create your own output modules (see later).
The main predefined output modules are:

<<| |@@class="empty"@@|=@@class="col2 c"@@Services|=@@colspan="2" class="col2 c"@@Coservices|
|@@class="empty"@@|=@@class="col2 c"@@|=@@class="col2 c"@@attached\\named~ /~ anonymous|=@@class="col2 c"@@non-attached\\named~ /~ anonymous|

|=Module|=description|=type|=options|
>>

;<<a_api| module Eliom_output.Html5 >> (and <<a_api| module Eliom_output.Xhtml >>)
: Allows to register functions that generate html5 pages statically checked using polymorphic variant types. You may use constructor functions from <<a_api | module Eliom_pervasives.HTML5.M >> (resp <<a_api | module Eliom_pervasives.XHTML.M >>) or a syntax extension close to the standard html syntax.
;<<a_api| module Eliom_output.Eliom_appl >>
: is a functor that generates a module allowing to create services belonging to a client-server Eliom application (see <<a_manual chapter="client"|chapter client-server applications>>)
;<<a_api| module Eliom_output.Caml >>
: allows to register services sending marshalled OCaml values
<<wip|Add a section on Eliom_output.Caml. Tell that it should be used instead of Block5 to get parts of the page>>
;<<a_api| module Eliom_output.Blocks5 >> (and <<a_api| module Eliom_output.Blocks >>)
: Allows to register functions that generate a portion of page using <<a_api | module Eliom_pervasives.HTML5.M >> (resp <<a_api | module Eliom_pervasives.XHTML.M >>) or the syntax extension. (useful for <<span class="code"|XMLHttpRequest>> requests for example).
;<<a_api| module Eliom_duce.Xhtml >>
: Allows to register functions that generate XHTML 1.1 pages   statically checked using <<span class="code"|OCamlduce>>. Typing is   stricter, and you need a modified version of the OCaml compiler   (OCamlduce).
;<<a_api| module Eliom_output.HtmlText >>
: Allows to register functions that   generate text html pages, without any typechecking of the content.   The content type sent by the server is "text/html".
;<<a_api| module Eliom_output.CssText >>
: Allows to register functions that   generate CSS pages, without any typechecking of the content.   The content type sent by the server is "{{{text/css}}}".
;<<a_api| module Eliom_output.Text >>
: Allows to register functions that   generate text pages, without any typechecking of the content.   The services return a pair of strings. The first one is the content   of the page, the second one is the content type.
;<<a_api| module Eliom_output.Action >>
: Allows to register actions (functions that do not generate any page, see <<a_manual chapter="services" fragment="actions"|Action>>). The page corresponding to the URL (without the coservice parameter that triggered the action) is reloaded after the action by default if possible.
;<<a_api| module Eliom_output.Unit >>
: is like <<a_api| module Eliom_output.Action >> but the URL is not reloaded after the action. (Same as {{{Eliom_output.Action}}} with {{{[`NoReload]}}} option).
;<<a_api| module Eliom_output.Redirection >>
: Allows to register HTTP redirections. The handler returns the service (without parameter) of the page you want to redirect to. The browser will get a 301 or 307 code in answer and redo the request to the new URL. To specify whether you want temporary (307) or permanent (301) redirections, use the <<span class="code"|?options>> parameter of registration functions. For example: <<span class="code"|register ~options:`Permanent ...>> or <<span class="code"|register ~options:`Temporary ...>>.
;<<a_api| module Eliom_output.String_redirection >>
: Same but the ouput type is a string. Use with care! Warning: According to the RFC of the HTTP protocol, the URL must be absolute!
;<<a_api| module Eliom_output.Files >>
: Allows to register services that send files. See <<a_manual chapter="services" fragment="eliomfiles"|here>> for an example of use.
;<<a_api| module Eliom_output.Any >>
: Allows to register services that can choose what they send, for example an xhtml page or a file, depending on some situation (parameter, user logged or not, page present in a cache ...). It is also possible to create your own modules for other types of pages. See <<a_manual chapter="services" fragment="any"|here>> for an example of use.

<<wip|Missing modules?>>


===@@id="eliomfiles"@@Sending files

You may want to register a service that will send files.
To do that, use the <<a_api| module Eliom_output.Files >> module. Example:

<<code language="ocaml"|
let sendfile =
  Files.register_service
    ~path:["sendfile"]
    ~get_params:unit
    (fun () () -> return "filename")
>>

Other example, with "suffix" services (see <<a_manual chapter="params" fragment="suffix"|here>>):
<<code language="ocaml"|
let sendfile2 =
  Files.register_service
    ~path:["files"]
    ~get_params:(suffix (all_suffix "filename"))
    (fun s () ->
      return ("//path//"^(Ocsigen_lib.string_of_url_path ~encode:false s)))
>>

The extension <<a_manual chapter="services" fragment="staticparts"|Staticmod>> is another way to
handle static files.



===Sending portions of pages


 The <<a_api| module Eliom_output.Blocks5 >> and <<a_api| module Eliom_output.Blocks >> modules allow you to register services that send portions of pages, of any "block" type for HTML5.M (resp. XHTML.M).
 It is sometimes useful to create AJAX pages
 (i.e. pages using the <<span class="code"|XMLHttpRequest>> Javascript object).
 Note that the service returns a list of blocks. For sending HTML
 to client side eliom application, <<a_api| module Eliom_output.Caml >> is better
 suited.


<<code language="ocaml"|let divpage =
  Eliom_output.Blocks.register_service
    ~path:["div"]
    ~get_params:unit
    (fun () () ->
      Lwt.return
        [div [h2 [pcdata "Hallo"];
              p [pcdata "Blablablabla"] ]])
>>


 The <<a_api| module Eliom_output.Make_TypedXML_Registration >> module
 allows to create other modules for registering portions of pages of
 other types.  For example, <<a_api| module Eliom_output.Blocks5 >> is
 defined by:

<<code language="ocaml"|module Blocks5 = Make_TypedXML_Registration(XML)(HTML5.M)(struct
  type content = HTML5_types.body_content
end)
>>


===@@id="redirections"@@Redirections


 The <<a_api| module Eliom_output.Redirection >> module allows you to register HTTP redirections.\\
If a request is made for such a service, the server asks the browser
to retry with another URL.

Such services return a GET service without parameter at all.
Example:
<<code language="ocaml"|let redir1 = Eliom_output.Redirection.register_service
    ~options:`Temporary
    ~path:["redir"]
    ~get_params:Eliom_parameters.unit
   (fun () () -> Lwt.return coucou)
>>


 If you want to give parameters to such services, use
 <<a_api | val Eliom_services.preapply>> (see also
 <<a_manual chapter="services" fragment="preapplied" |later in the tutorial>>).
 Example:


 <<code language="ocaml"|let redir = Eliom_output.Redirection.register_service
    ~options:`Temporary
    ~path:["redir"]
    ~get_params:(int "o")
   (fun o () ->
      Lwt.return
        (Eliom_services.preapply coucou_params (o,(22,"ee"))))
>>


The <<span class="code"|options>> parameter may be either
  <<span class="code"|`Temporary>> or <<span class="code"|`Permanent>>.



[[site:tuto/redir?o=11| Try it]].

Note that the cost of a redirection is one more request and
one more response.


===@@id="actions"@@Actions


Actions are services that do not generate any page.
Use them to perform an effect on the server (connection/disconnection
of a user, adding something in a shopping basket, deleting a message in
a forum, etc.). By default,
the page you link to is redisplayed after the action.
For example, when you have the same form (or link) on several pages
(e.g.  a connection form),
instead of making a version with post params of all these pages,
you can use a single action, registered on a //non-attached coservice//
(see below).
<<|To register actions, just use the module <<a_api| module Eliom_output.Action >>
instead of <<a_api| module Eliom_output.Xhtml >> (or <<a_api| module Eliom_duce.Xhtml >>, etc.).
For example
 <<span class="Cem"|<<a_api | val Eliom_output.Action.register>>>>,
 <<span class="Cem"|<<a_api | val Eliom_output.Action.register_service>>>>.
>>
\\

See more details and an example in the section about non-attached coservices
below, or in section * * connection-of-user.

The return type of action handlers is
<<span class="code"|unit Lwt.t>>.
We will see <<a_manual chapter="services" fragment="infofallbacks" |later>> how to transmit information
to the service that will take charge of the generation of the page.\\

A common use of actions and non-attached coservices working together
is the implementation of login/logout forms.
An example is given in the chapter about the server-side state
of the application (section sec-state-connect).
In that example, actions and non-attached coservices make staightforward
the implementation of the behaviour you generally want for such features:
* Connection and disconnection stay on the same page,
* If you want a connection/disconnection form on each page, no need
  to create a version with POST parameters of each service.

The implementation of the same behaviour with usual Web programming techniques
is usually much more complicated.



===@@id="any"@@Registering services that decide what they want to send===

You may want to register a service that will send, for instance,
  sometimes
  an XHTML page, sometimes a file, sometimes something else.
  To do that, use the <<a_api| module Eliom_output.Any >> module, together
  with the <<span class="code"|send>> function of the module you want
  to use. Example:


<<code language="ocaml"|let send_any =
  Eliom_output.Any.register_service
    ~path:["sendany"]
    ~get_params:(string "type")
   (fun s () ->
     if s = "valid"
     then
       Eliom_output.Xhtml.send
         (html
            (head (title (pcdata "")) [])
            (body [p [pcdata
                        "This page has been statically typechecked.
                         If you change the parameter in the URL you will
                         get an unchecked text page"]]))
     else
       Eliom_output.HtmlText.send
         "<html><body><p>It is not a valid page. Put type=\"valid\" in the
          URL to get a typechecked page.</p></body></html>"
   )
>>


  See [[site:tuto/sendany?type=valid| a valid page]],
  and [[site:tuto/sendany?type=non+valid| a non valid page]].




You may also use <<a_api| module Eliom_output.Any >> to personalize the charset
(default charset is set in configuration file), the HTTP code,
the content type or to add some HTTP headers.
To do that use the optional parameters
(<<span class="code"|?code>>, <<span class="code"|?charset>> etc.) of the
 <<span class="code"|send>> function.

===Creating your own output modules===

<<wip|To be written>>

==Service identification mechanism==

The choice of the service to handle a request is done automatically by
Eliom, according the HTTP method (GET or POST), the URL path
and/or (GET or POST) parameters. This is called
//service identification//.
Up to now, we have seen very simple services. But
Eliom's service identification mechanism is very powerful and
you can rely on it to simplify a lot the implementation of complex
web interactions.

Before beginning the implementation of a Web site,
think about the URLs you want to create as entry points to your Web site,
and the services you want to provide. It is not clean to pollute
the path tree by creating "dummy URLs"
that will be used only to perform an effect and do a redirection.
Eliom always has a better solution.\\


The services we've used so far are called //main services//.
There are other kinds of services depending on the precise
behavior you want for links and forms. Clicking on a link or a form
may trigger:



*the request of a new document (page) (or not),
*the sending of data to the server using the POST method (or not),
*an action on the server (or not),
*a change of URL (or not).




To take into account all possible behaviours with respect to URLs,
  Eliom uses three kinds of services.  Although we will provide more details and examples later,
we'll start with a brief definition:
;@@class="blue"@ @@Main services
:are the main entry points of your sites.
  Created by <<span class="code"|service>> or
  <<span class="code"|post_service>>.
  They correspond to the public URLs of your Web site, and will last
  forever.
;Attached coservices
:are services that share their
  location (URL) with a main service (fallback).
  They are distinguished from that main service using a special parameter
  (added automatically by Eliom), containing either the name of the
  coservice or a number generated automatically.
  They are often created dynamically for one user
  (usually in the session table), depending on previous interaction
  during the session.
  Sometimes, you want them to disappear after a timeout, letting
  the fallback answer afterwards.
  Another use of (POST) coservices is to customize one
  button but not the page it leads to (like the disconnect button
  in the example of sessions with //actions// as below: it goes to the
  page corresponding to the visible URL, but also disconnect the user
  as side effect).
;Non-attached coservices
:are
  coservices that are not
  attached to a particular URL. A link to a non-attached
  coservice will go to the current URL with a special parameter
  containing either the name of the service, or a number generated
  automatically (and different each time).
  It is useful when you want the same link or form on several pages
  (for example a connection box) but you don't want to go to another
  URL. Non-attached coservices are often used with //actions//
  (see below).

To summarize, if you want to go to another URL, use
attached coservices. If you want to stay on the same URL
use non-attached coservices.

As mentionned above, attached and non-attached coservices can be //named//
or //anonymous// (in the latter case, a random and cryptographically safe
number is generated by Eliom). Use named coservices when you want to
recreate them after relaunching the server without breaking the links
forms and any associated bookmarks. Use anonymous coservices for example
when you need to create (automatically) a new coservice for a short amount
of time. Coservices are anonymous by default. Add the optional {{{~name}}}
parameter if you want them to be named.

<<concept title="Dynamic creation of services" |

One unique feature of Eliom that few Web programming frameworks provide,
is the ability to //create dynamically new services//.

This allows, for example, the creation of personalized services that depend on previous
interaction on a per-user basis!  This corresponds exactly to what is called
//continuation based Web programming//. As we will see later
(example * calc * *), this makes it really easy to implement a succession
of links and forms that are derived from one another, and with the expected
behaviour if the user presses the "back" button or duplicates the browser
window.
Such a behaviour is difficult to simulate with traditional Web
programming and is often the cause of serious errors in many sites
(for example, travel ticket booking, etc).

Continuations for Web programming have been introduced by
<<span class="wip"|Missing tilde in link before queinnec>>
[[http://www-spi.lip6.fr/queinnec/PDF/www.pdf| Christian Queinnec]],
and are a big step forward in the understanding of Web interaction.

Some programming languages (e.g. Scheme) allow one to manipulate
continuations using //control operators// (like
<<span class="code"|call/cc>>). The style of programming used by Eliom
is closer to //Continuation Passing Style// (CPS), and has the
advantage that it does not need control operators, and fits
the paradigm of Web programming very well.

If you want dynamic services dedicated to a particular user,
it is possible (even if not necessary)
to register it with scope {{{`Session}}} (see chapter * *).\\

Another use of dynamic services is to add new features to your Web site
(for example, if a user creates a blog and you want to add a new URL for her).
In that case, be very careful to recreate the services when relaunching the
server (for example by retrieving the information from a database).
>><<|concept>>

===@@id="coservices"@@Coservices

Very often, GET anonymous coservices are created dynamically with
respect to previous interaction with the user (and are registered
with scope {{{`Session}}}). They allow us to establish a precise semantics for the
"back" button of the browser (that is to say, make sure that you will go back to the
past page) or bookmarks, or duplication of the browser's window.
(See the <<a_manual chapter="services" fragment="coservicesinsessiontable" |<<span class="code"|calc>>>> example below).

Use POST coservices if you want to customize a link or form,
but not the URL it points to. More precisely, POST coservices are mainly
used in two situations:
* For the same purpose as GET coservices (new services
corresponding to precise points of the interaction with the user)
but when you don't want this service to be bookmarkable.
* To create a button that leads to a service after having performed
a side-effect. For example a disconnection button that leads to the main
page of the site, but with the side effect of disconnecting the user.

To create a coservice, use
<<span class="Cem"| <<a_api| val Eliom_services.coservice >>>> and
<<span class="Cem"| <<a_api| val Eliom_services.post_coservice >>>>.
Like  <<a_api| val Eliom_services.post_service >>,
they take a public service as parameter
(labeled <<span class="code"|fallback>>)
to be used as fallback when the user comes back without the coservice
identifier (for example if it was a POST coservice and/or the coservice
has expired).



The following example shows the difference between GET coservices
(bookmarkable) and POST coservices:

<<code language="ocaml"|(************************************************************)
(************** Coservices. Basic examples ******************)
(************************************************************)

(* -------------------------------------------------------- *)
(* We create one main service and two coservices:           *)

let coservices_example =
  Eliom_services.service
    ~path:["coserv"]
    ~get_params:Eliom_parameters.unit
    ()

let coservices_example_post =
  Eliom_services.post_coservice
    ~fallback:coservices_example
    ~post_params:Eliom_parameters.unit
    ()

let coservices_example_get =
  Eliom_services.coservice
    ~fallback:coservices_example
    ~get_params:Eliom_parameters.unit
    ()


(* -------------------------------------------------------- *)
(* The three of them display the same page,                 *)
(* but the coservices change the counter.                   *)

let _ =
  let c = ref 0 in
  let page () () =
    let l3 = Eliom_output.Xhtml.post_form coservices_example_post
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"incr i (post)" ()]]) ()
    in
    let l4 = Eliom_output.Xhtml.get_form coservices_example_get
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"incr i (get)" ()]])
    in
    return
      (html
       (head (title (pcdata "")) [])
       (body [p [pcdata "i is equal to ";
                 pcdata (string_of_int !c); br ();
                 a coservices_example [pcdata "reload"] (); br ();
                 a coservices_example_get [pcdata "incr i"] ()];
              l3;
              l4]))
  in
  Eliom_output.Xhtml.register coservices_example page;
  let f () () = c := !c + 1; page () () in
  Eliom_output.Xhtml.register coservices_example_post f;
  Eliom_output.Xhtml.register coservices_example_get f
>>


Try [[site:tuto/coserv|<<span class="code"|coserv>>]].



Note that if the coservice does not exist (for example, if it
has expired), the fallback is called.

In this example, coservices do not take any parameters
(but the coservice identifier), but you can also create coservices that do accept
parameters. Note that the fallback of a GET coservice cannot take
parameters. But as coservices parameters have special
names, it is possible to use a "pre-applied" service as fallback
(<<a_manual chapter="services" fragment="preapplied" |see later>>).


===@@id="coservicesinsessiontable"@@Dynamic coservices===

You can register anonymous coservices (usually with scope {{{`Session}}})
for run-time creation of new services dedicated to a particular user.
Here is an example of two pages that add two integers.
Once the first number is submitted by the user, a coservice
is created and registered in the session table. This service
takes the second number as a parameter and displays the result of
the sum of the two numbers.
Try to duplicate the pages and/or to use the "back" button of your
browser to verify that it has the expected behaviour.

(See chapter * * if you want more explanations on forms and parameters).

<<code language="ocaml"|(************************************************************)
(*************** calc: sum of two integers ******************)
(************************************************************)

(*zap* *)
let state_name = "calc_example"
(* *zap*)
(* -------------------------------------------------------- *)
(* We create two main services on the same URL,             *)
(* one with a GET integer parameter:                        *)

let calc =
  Eliom_output.Html5.service
    ~path:["calc"]
    ~get_params:Eliom_parameters.unit
    ()

let calc_i =
  Eliom_output.Html5.service
    ~path:["calc"]
    ~get_params:(Eliom_parameters.int "i")
    ()


(* -------------------------------------------------------- *)
(* The handler for the service without parameter.           *)
(* It displays a form where you can write an integer value: *)

let calc_handler () () =
  let create_form intname =
    [p [pcdata "Write a number: ";
        Eliom_output.Xhtml.int_input ~input_type:`Text ~name:intname ();
        br ();
        Eliom_output.Xhtml.string_input ~input_type:`Submit ~value:"Send" ()]]
  in
  let f = Eliom_output.Xhtml.get_form calc_i create_form in
  return
    (html
       (head (title (pcdata "")) [])
       (body [f]))


(* -------------------------------------------------------- *)
(* The handler for the service with parameter.              *)
(* It dynamically creates and registers a new coservice     *)
(* with one GET integer parameter.                          *)
(* This new coservice depends on the first value (i)        *)
(* entered by the user.                                     *)

let calc_i_handler i () =
  let create_form is =
    (fun entier ->
       [p [pcdata (is^" + ");
           int_input ~input_type:`Text ~name:entier ();
           br ();
           string_input ~input_type:`Submit ~value:"Sum" ()]])
  in
  let is = string_of_int i in
  let calc_result =
    register_coservice ~scope:`Session
      ~fallback:calc
      ~get_params:(int "j")
      (fun j () ->
        let js = string_of_int j in
        let ijs = string_of_int (i+j) in
        return
          (html
             (head (title (pcdata "")) [])
             (body
                [p [pcdata (is^" + "^js^" = "^ijs)]])))
  in
  let f = get_form calc_result (create_form is) in
  return
    (html
       (head (title (pcdata "")) [])
       (body [f]))


(* -------------------------------------------------------- *)
(* Registration of main services:                           *)

let () =
  Eliom_output.Xhtml.register calc   calc_handler;
  Eliom_output.Xhtml.register calc_i calc_i_handler
>>


[[site:tuto/calc| See the result]].




<<concept title="URLs" |


While designing a Web site, think carefully about the URLs you
want to use. URLs are the entry points for your site. Assume that
they will be bookmarked. If you create a link, you want to go to
another URL and you want a page to be generated. That page may be
the default page for the URL (the one you get when you go back
to a bookmarked page), or another page that depends on the specific
link or form you originally used to go to that URL (link to a coservice,
or page depending on post data).
Sometimes, you want the user to initiate an activity on the server by clicking
a link or submitting a form, without changing the URL.
You can do this using //non-attached coservices// (see below).



>> <<|concept>>

====@@id="non-attached_coservices"@@Non-attached coservices


Non-attached coservices are coservices that are not attached to an URL path.
Service identification is performed only according to the coservice
identifier, whatever be the path.
When you point a link or a form towards such a service, the URL path
and the main parameters do not change.
The parameters of the non-attached coservice are sent as special parameters.

As for attached coservices, there are GET and POST versions,
and each of them may be either named or anonymous.

To create a non-attached coservice, use
 <<a_api| val Eliom_services.coservice' >> or
 <<a_api| val Eliom_services.post_coservice' >>
(note the "prime" at the end). <<span class="wip"|find better function names?>>
POST non-attached coservices are really useful if you want a
link or form to be present on every page but you don't want the
URL to change. Typically, non-attached POST coservices are
used with //actions// or //redirections//.

Here is one simple example. Suppose you wrote a function
<<span class="code"|remove>> to remove one piece of data from a database
(taking an identifier of the data).
If you want to put a link on your page to call this function
and redisplay the page, just create an action on a non-attached coservices
like this:

<<code language="ocaml"|let remove_action =
  Eliom_output.Action.register_post_coservice'
    ~post_params:(Eliom_parameters.int "id")
    (fun () id -> remove id)
>>

Then wherever you want to add a button to do that action
(on data <<span class="code"|id>>), create a form like:

<<code language="ocaml"|Eliom_output.Html5.post_form remove_action
  (fun id_name ->
     Eliom_output.Html5.int_input
       ~input_type:`Hidden ~name:id_name ~value:id ();
     Eliom_output.Html5.string_input
       ~input_type:`Submit ~value:("remove "^string_of_int id) ())
>>

===@@id="scope"@@Scope of services===

By default, services and coservices are accessible to anybody.
It is possible to restrict the //scope// of a service,
making it available only to a session, a client side process,
or a group of sessions (see chapter * * for more information on scopes).

The same service can be registered with several scopes.
This makes it possible, for example, to generate custom services for a specific user.
Eliom will try to find the service by trying the following (in order):
* scope client-side process,
* scope session,
* scope group of session, and
* global scope.

If the service has not been found, and it is a
<<span class="wip"|anonymous?>> coservice, it will then try the fallback,
in the same scoping order.

To set the scope of a service registration, add the optional
parameter {{{~scope}}} to the {{{register}}} function, that may take
value of the type
{{{[ `Global | `Session_group | `Session | `Client_process ]}}}.


===Examples===

The most commonly used services are:

* Main services (GET or POST) (with global scope) for public
pages.
* GET attached coservices in session service table to make the
browser's "back" button actually move to a previous step or page in the user's interaction,
and to allow several tabs on different versions of the same page
(several steps interaction).
* Actions registered on POST named non-attached coservices
to cause an effect
on the server, from any page, and without changing the URL
(login/logout, for example).

Here is a list of frequent Web interaction issues
and the solution Eliom provides to solve them.
;Display the result of a search
:Use a coservice (anonymous, with timeout)
in the session service table.
;Keep information about the session (name of the user~ ...)
:Use eliom references (scope {{{`Session}}}), see chapter * * .
;A connection or disconnection box on each page of your site
:Use actions registered on named non-attached coservices to set or
 remove data from a session data table.
;Add something to a shopping basket
:Use an action registered on a non-attached coservice,
with the names of the items as parameters. The action saves the shopping
basket in an eliom reference (scope {{{`Session}}}).
Thus, the shopping basket will remain
even if the user pushes the "back" button of his browser.
;Book a ticket (in several steps)
:Each step creates new (GET) coservices (with or without
parameters, all attached to the service displaying the main
booking page)
according to the data entered by the user. These
coservices are registered with scope {{{`Session}}} (with a timeout for
the whole session or for each of them). Thus the user can go back
to a previous state, or keep several proposals on different
tabs before choosing one.
;...
://Help us to complete this list by giving your examples or
asking questions about other cases! Thank you!//
;



===@@id="detailsonserviceregistration"@@Details on service registration===

<<concept title="Tips and advices" |

*All services created during initialization must be registered
(with global scope) during the initialization phase of your module.
If not, the server will not start (providing  an appropriate error message in the logs).
This will prevent broken links.

* Services may be registered only during the server's initialization phase
(while reading the site configuration) or while processing a request,
because Eliom must know the information about the site. Be very careful
about this if you want to use static linking (see chapter * * for more
information on static linking).

* All services (but not coservices) must be created in a module loaded
inside a <<span class="code"|<host>>> tag of the configuration file.
It is not possible to accomplish this using modules loaded inside
<<span class="code"|<extension>>> or <<span class="code"|<library>>>.

* If you create new main services dynamically,
you will dynamically create new URLs!
This may be dangerous as they will disappear if you stop the server.
Be very careful to re-create these URLs when you relaunch the server,
otherwise, some external links or bookmarks will be broken!\\
The use of that feature is discouraged for coservices
without timeout, as such coservices will be available only until the end
of the server process (and it is not possible to re-create them with the
same key).

*Do not register the same service (with scope global) twice,
and do not replace a service
by a directory (or vice versa). If this happens during the
initialization phase, the server won't start.
If this happens after server startup, it will be ignored (with a warning in the
logs).

*GET coservices (without POST parameters) can be registered
only with a main service without GET/POST parameters as fallback.
But it may be a
<<a_manual chapter="services" fragment="preapplied" |//preapplied//>>
service (see below).

*Services with POST parameters (main service or coservice)
can be registered with a (main or co-) service without POST
parameters as fallback.
*The registration of (main) services must be completed before
the end of the loading of the module. It is not possible to launch
a (Lwt) thread with the intention that it will register a service later, as
registering a service needs access to config file
information (for example the directory of the site).
If you do this, the server will raise
<<a_api | exception Eliom_common.Eliom_function_forbidden_outside_site_loading >>
most of the time,
but you may also get unexpected results (if the thread is executed
while another site is loaded).
If you use threads in the initialization phase of your module
(for example if you need information from a database),
use  <<a_api project="lwt" | val Lwt_unix.run >> to wait the end of the thread.
>><<|concept>>


==Other features==

===Secure services


You may want to impose HTTPS for some or all of your services.
 To do that, use the optional parameter <<span class="code"|~https:true>>
 while creating your service.

It is also possible to ask for HTTPS while creating a link or
a form (using the optional parameter <<span class="code"|~https:true>>).
But it is never possible to make a http link that points to an https service,
even if you request it.

Warning: if the protocol needs to be changed (from HTTP to HTTPS
or vice versa), Eliom will generate absolute URLs.
The host name and port numbers are guessed from the IP and the
configuration by default, but it is recommended to specify them
in the configuration file. For example:

<<div class="pre"|<host hostfilter="*.org" defaulthostname="www.mywebsite.org"
defaulthttpport="8080" defaulthttpsport="4433">
  ...
</host>
>>


===Priority of services

When creating a service (but not a coservice) you can add the optional
{{{int}}} parameter {{{~priority}}} to set the priority of the service.
The default priority is 0. Services with higher priority
will be tried by Eliom before the ones with lower priority.
Use this when several services are configured to respond to the same request.

===Timeouts for coservices


It is possible to use timeouts with coservices using
the optional parameter <<span class="code"|?timeout>> of functions
<<span class="code"|coservice>>,
<<span class="code"|coservice'>>, etc.
Note that session coservices cannot survive after the end of the session.
Use this if you don't want your coservice to be available during the entirety of the
session duration. For example if your coservice is here to show the
results of a search, you probably want it to be available only for
a short time. The following example shows a coservice with timeout
registered with scope {{{`Session}}}.

<<code language="ocaml"|let timeout = service ["timeout"] unit ()

let _ =
  let page () () =
    let timeoutcoserv =
      Eliom_output.Html5.register_coservice
        ~scope:`Session
        ~fallback:timeout
        ~get_params:unit
        ~timeout:5.
        (fun _ _ ->
           Lwt.return
             (html
               (head (title (pcdata "Coservices with timeouts")) [])
               (body [p
                 [pcdata "I am a coservice with timeout."; br ();
                  pcdata "Try to reload the page!"; br ();
                  pcdata "I will disappear after 5 seconds of inactivity." ];
                 ])))
    in
    Lwt.return
      (html
        (head (title (pcdata "Coservices with timeouts")) [])
        (body [p
          [pcdata "I just created a coservice with 5 seconds timeout."; br ();
           a timeoutcoserv [pcdata "Try it"] (); ];
          ]))
  in
  Eliom_output.Html5.register timeout page
>>

[[site:tuto/timeout| See this example here]].




===Disposable coservices


It is possible to set a limit to the number of uses of
  (attached or non-attached) coservices. Just give the maximum number
  of uses with the optional <<span class="code"|?max_use>> parameter while
  creating your coservices. Example

<<code language="ocaml"|let disposable = service ["disposable"] unit ()

let _ = register disposable
(fun () () ->
      let disp_coservice =
        coservice ~max_use:2 ~fallback:disposable ~get_params:unit ()
      in
      register ~scope:`Session ~service:disp_coservice
        (fun () () ->
          return
            (html
              (head (title (pcdata "")) [])
              (body [p [pcdata "I am a disposable coservice";
                        br ();
                        a disp_coservice [pcdata "Try me once again"] ()]]))
        );
      return
        (html
          (head (title (pcdata "")) [])
          (body [p [(if Eliom_request_info.get_link_too_old ()
                    then pcdata "Your link was outdated. I am the fallback. I just created a new disposable coservice. You can use it only twice."
                    else
                    pcdata "I just created a disposable coservice. You can use it only twice.");
                    br ();
                    a disp_coservice [pcdata "Try it!"] ()]])))
>>

[[site:tuto/disposable| Try it]].





===@@id="csrf"@@CSRF-safe services

Eliom implements a protection against CSRF attacks.

====What is CSRF?====

CSRF means //Cross Site Request Forgery//.
Here is an explanation from Wikipedia:

For example, one user, Bob, might be browsing a chat forum where another user,
Mallory, has posted a message. Suppose that Mallory has crafted an HTML image
element that references a script on Bob's bank's website (rather than an image
file), e.g.,\\
{{{<img src="http://bank.example/withdraw?account=bob&amount=1000000&for=mallory">}}}\\
If Bob's bank keeps his authentication information in a cookie, and if the
cookie hasn't expired, then the attempt by Bob's browser to load the image
will submit the withdrawal form with his cookie, thus authorizing a
transaction without Bob's approval.

====Solution with Eliom <= 1.2====

There is an easy way to protect a service from such attacks with Eliom 1.2:
just create a new anonymous coservice with timeout each time you display the
form. Thus, a new token will be created for each form and no service will
answer if you do not send it (or more precisely, the fallback will).


====CSRF-safe services====

In order to simplify this, Eliom add this possibility:

* When creating a new coservice, you can give the optional
  {{{~csrf_safe}}} parameter
* If this parameter is {{{true}}}, actual registration of the service
  will be delayed and performed each time a form is created that
  points to this coservice.

Example:
<<code language="ocaml"|
let csrfsafe_example =
  Eliom_services.service
    ~path:["csrf"]
    ~get_params:Eliom_parameters.unit
    ()

let csrfsafe_example_post =
  Eliom_services.post_coservice
    ~csrf_safe:true
    ~csrf_secure:true
    ~timeout:10.
    ~max_use:1
    ~https:true
    ~fallback:csrfsafe_example
    ~post_params:Eliom_parameters.unit
    ()

let _ =
  let page () () =
    let l3 = Eliom_output.Xhtml.post_form csrfsafe_example_post
        (fun _ -> [p [Eliom_output.Xhtml.string_input
                        ~input_type:`Submit
                        ~value:"Click" ()]]) ()
    in
    Lwt.return
      (html
       (head (title (pcdata "CSRF safe service example")) [])
       (body [p [pcdata "A new coservice will be created each time this form is displayed"];
              l3]))
  in
  Eliom_output.Xhtml.register csrfsafe_example page;
  Eliom_output.Xhtml.register csrfsafe_example_post
    (fun () () ->
       Lwt.return
         (html
            (head (title (pcdata "CSRF safe service")) [])
            (body [p [pcdata "This is a CSRF safe service"]])))

>>


If you register the service with global scope, the CSRF-safe service
will be available for everybody.  However, the actual (delayed)
registration will take place with a restricted scope (default:
{{{`Session}}}), described by {{{?csrf_scope}}},
{{{?csrf_state_name}}} and {{{?csrf_secure}}} (corresponding to
{{{?scope}}}, {{{?state_name}}} and {{{?secure}}}).

If you use {{{register ~scope:`Session}}}, the coservice will be
available only for one session.  The actual registration will take
place in the same session table, described by {{{?csrf_state_name}}}
and {{{?csrf_secure}}}.  In that case, the parameters
{{{?state_name}}} and {{{?secure}}} of {{{register}}} must be exactly
the same.



===@@id="preapplied"@@Pre-applied services


Services or coservices with GET parameters can be preapplied
 to obtain a service without parameters. Example:




<<code language="ocaml"|let preappl = Eliom_services.preapply coucou_params (3,(4,"cinq"))

>>


 It is not possible to register something on a preapplied service,
 but you can use them in links or as fallbacks for coservices.




===@@id="preapplied"@@Void coservices


 <<a_api| val Eliom_services.void_coservice' >>
is a special non-attached action, with special behaviour:
it has no parameter at all, even non-attached parameters.
Use it if you want to make a link to the current page
without non-attached parameters.
It is almost equivalent to a POST non-attached coservice without POST
parameters, on which you register an action that does nothing,
but it is using GET method, so that you can use it with
<<span class="code"|<a>>> links, not only forms.
Example:

<<code language="ocaml"|
Eliom_duce.Xhtml.a
  ~service:Eliom_services.void_coservice'
  {{ "cancel" }}
  ()
>>

There is also
 <<a_api| val Eliom_services.https_void_coservice' >>
(same, but forces use of HTTPS),
 <<a_api| val Eliom_services.void_hidden_coservice' >>, and
 <<a_api| val Eliom_services.https_void_hidden_coservice' >>. "Hidden" means that they keep GET non attached parameters.

Use <<a_api| val Eliom_services.void_hidden_coservice' >> for example
after a POST request
if you want to do a redirection towards the same page without POST parameters
(and thus prevent from reposting data if the user reloads the page).

See an example of use in chapter * * section * * (connection of users with
session groups).


===@@id="infofallbacks"@@Get information on what succeeded before the service===

The function
 <<a_api| val Eliom_request_info.get_link_too_old >>
returns <<span class="code"|true>> if the coservice called has not been found.
In that case, the current service is the fallback.

The function
 <<a_api| val Eliom_request_info.get_expired_service_sessions >>
returns the list of names of service sessions expired
for the current request.

It is also possible to send other information to the service occuring after
an action, by using //Eliom references// with scope {{{`Request}}}
(see chapter * *).
